---
title: "Examen statistique sous R"
author: |
  <div style="display: flex; justify-content: space-between;">
    <div>
      Rédigé par : 
      HABA Fromo Francis
     
    </div>
    <div style="text-align: right;">
      Sous la supervision de :
      
      M. Aboubacar Hema 
      
      Research Analyst   
    </div>
  </div>
date: "Année scolaire : 2024/2025"
output:
  prettydoc::html_pretty:
    theme: cayman
    css: custom.css
---
<!-- Logos alignés en haut de la page -->
<div style="text-align: center; margin-bottom: 20px;">
  <img src="../IMAGES/LOGO3.jpg" height="80" style="margin-right: 20px;">
  <img src="../IMAGES/LOGO2.jpg" height="80" style="margin-right: 20px;">
  <img src="../IMAGES/LOGO1 (1).jpg" height="80"style="margin-right: 20px;">
</div>

                                      Objectif :
                                      
                                      
    S’assurer que les bases sont bien lues et comprendre leur structure.
    
                                Justification :
                                
    Cela permet de comprendre les variables disponibles dans chaque base 
    
    et d’identifier celles qui pourront servir pour faire la jonction ou la
    
                                    comparaison
    
    
                    1. Chargement et aperçu des données
```{r echo=TRUE, message=FALSE, warning=FALSE}
library(haven)
Base_Individus <- read_dta("../BASES/Base_Individus.dta")
library(haven)
Base_Principale <- read_dta("../BASES/Base_Principale.dta")




```
Aperçu des premières lignes  et la Vérification des dimensions,des noms de                                         colonnes   
```{r echo=TRUE, message=FALSE, warning=FALSE}
head(Base_Individus)
head(Base_Principale)
dim(Base_Individus)
dim(Base_Principale)
names(Base_Individus)
names(Base_Principale)
```
           2.Vérification de l'identifiant commun
           
                     Justification : 
                     
Pour faire une jointure correcte, il faut que l’identifiant soit unique 

              dans au moins une des deux bases.
              
              Vérication de l'unicité de l'identifiant dans chaque base
```{r echo=TRUE, message=FALSE, warning=FALSE}
sum(duplicated(Base_Individus$ID))
sum(duplicated(Base_Principale$ID))

```
             3.Comparaison des identifiants entre les deux bases 
             
 Identifier les ID présents dans Base_Individus mais absents de Base_Principale
 
Identifier les ID présents dans Base_Principale mais absents de Base_Individus

                                  Justification :
                                  
Ces écarts peuvent signaler des erreurs de saisie ou des individus mal appariés                                   entre les bases.
```{r echo=TRUE, message=FALSE, warning=FALSE}
setdiff(Base_Individus$ID,Base_Principale$ID)
setdiff(Base_Principale$ID,Base_Individus$ID)

```
            4.Vérification de cohérence des variables communes
            
             Justification :
             
On teste si les informations qui doivent être identiques

     entre les deux bases le sont effectivement.
```{r echo=TRUE, message=FALSE, warning=FALSE}
table(Base_Individus$admin0)
table(Base_Principale$admin0)
library(dplyr)
jointure<-left_join(Base_Individus,Base_Principale,by="ID",suffix = c("_ind","_princ"))
sum(jointure$admin0_ind !=jointure$admin0_princ,na.rm = TRUE)


```
                    5.Synthèse des incohérences
                    
                    Création d’un tableau récapitulatif
```{r echo=TRUE, message=FALSE, warning=FALSE}
incohérences<-jointure%>%
  filter(admin0_ind!=admin0_princ|is.na(admin0_ind)|is.na(admin0_princ))
print(incohérences)
```
      II.	Analyse socio-economique des deplaces internes du Sudan en 2023: 
      
                                             
                  1.Pyramide des ages des individus
                  
                  Recoder les modalités de la variable sexe
```{r echo=TRUE, message=FALSE, warning=FALSE}
Base_Individus<-Base_Individus %>%
  mutate(HH_02=recode(as.character(HH_02),
                         '1'="Male",
                         '2'="Female"))

```


```{r echo=TRUE, message=FALSE, warning=FALSE}
str(Base_Individus$ageYears)
summary(Base_Individus$ageYears)
```
                     Vérifier et nettoyer la variable Age
                    

```{r echo=TRUE, message=FALSE, warning=FALSE}
Base_Individus<-Base_Individus%>%
  mutate(ageYears=as.numeric(ageYears))%>%
  filter(!is.na(ageYears))
```


```{r echo=TRUE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(dplyr)


Base_Individus <- Base_Individus %>%
  mutate(
    ageYears = as.numeric(ageYears),  
    Groupe_ageYears = cut(
      ageYears,
      breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, Inf),  
      labels = c("0-5", "5-10", "10-15", "15-20", "20-25",
                 "25-30", "30-35", "35-40", "40-45", "45-50",
                 "50-55", "55-60", "60-65", "65-70", "70-75",
                 "75-80", "80-85", "85+"),
      right = FALSE   
    )
  )

```
     Regroupement et comptage des individus par sexe et groupe d'âge

```{r echo=TRUE, message=FALSE, warning=FALSE}
df_age <- Base_Individus %>%
  group_by( Groupe_ageYears, HH_02) %>%
  summarise(Population = n()) %>%
  ungroup()
df_age <- df_age %>%
  mutate(Population = ifelse(HH_02 == "Male", -Population, Population))


```

          Création de la pyramide des âges avec ggplot2
```{r echo=TRUE, warning=FALSE}
ggplot(df_age, aes(x = Groupe_ageYears, y = Population, fill = HH_02)) +
  geom_bar(stat = "identity", width = 0.8) +           
  coord_flip() +                                    
  scale_y_continuous(labels = abs) +                  
  labs(title = "Pyramide des âges des déplacés internes du Soudan (2023)",
       x = "Tranches d'âge",
       y = "Effectifs",
       fill = "Sexe") +
  scale_fill_manual(values = c("Male" = "steelblue", "Female" = "salmon")) +
  theme_minimal()
```

      2. Caracteristiques du chef de menage
      
      Produisez un tableau similaire
```{r}
library(dplyr)
library(janitor)
library(gtsummary)
Base_Individus %>%
  labelled::to_factor()%>%
  select(ageYears, HH_02, HH_08, Intro_07_1) %>%
  tbl_summary(
    by = Intro_07_1,  
    statistic = list(
      all_continuous() ~ "{mean} ({min}, {max})",
      all_categorical() ~ "{p}%"
    ),
    digits = all_continuous() ~ 1
  ) %>%
  add_p(
    test = list(
      ageYears ~ "wilcox.test",
      HH_02 ~ "chisq.test",
      HH_08 ~ "fisher.test"
    )
  ) %>%
  modify_header(label ~ "**Caractéristiques du chef de ménage**") %>%
  bold_labels()



```
      3.Crowding Index ou l’indice d’affluence
      
      a.Calculez le nombre d’individus par ménage
      
      
```{r echo=TRUE, message=FALSE, warning=FALSE}

library(dplyr)
menage_individus <- Base_Individus %>%
  group_by(ID) %>%
  summarise(nb_individus = n())
head(menage_individus)

```
      b.Statistiques descriptives sur le nombre d’individus par ménage

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(menage_individus$nb_individus)

```
          c.Statistiques descriptives sur le nombre de pièces par ménage        
```{r echo=TRUE, message=FALSE, warning=TRUE}

menage_pieces <- Base_Principale %>%
  select(ID, HH14) %>%
  distinct()

summary(menage_pieces$HH14)

```
        d.Calcul de l’indice d’affluence (Crowding Index)              
            
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Fusion des deux tableaux: individus + pièces
crowding_data <- menage_individus %>%
  left_join(menage_pieces, by = "ID") %>%
  mutate(crowding_index = nb_individus / HH14)

head(crowding_data)

```
     e.Proportions par tranche de Crowding Index  
     
```{r echo=TRUE, message=FALSE, warning=FALSE}

crowding_data <- crowding_data %>%
  mutate(crowding_cat = case_when(
    crowding_index < 1 ~ "<1",
    crowding_index >= 1 & crowding_index < 2 ~ "1-<2",
    crowding_index >= 2 & crowding_index < 3 ~ "2-<3",
    crowding_index >= 3 ~ ">=3"
  ))


prop.table(table(crowding_data$crowding_cat))


```
   Analyse descriptive des variables composant le SCA 
   
   Cela montre la distribution (min, max, médiane, etc.) de la consommation sur 7 jours pour chaque                                                   groupe
   
```{r echo=TRUE, message=FALSE, warning=FALSE}
Food<-Base_Principale%>%select(Food00,Food_bneed_a,Food_div1,Final_01,food_number_of_days)
summary(Food)
```
                          b. Calculer le score de consommation alimentaire (SCA)
```{r echo=TRUE, message=FALSE, warning=FALSE}
library(dplyr)


Food <- Base_Principale %>%
  select(Food00, Food_bneed_a, Food_div1, Final_01, food_number_of_days) %>%
  mutate(across(everything(), ~as.numeric(as.character(.))))  # conversion sécurisée


Food <- Food %>%
  mutate(
    SCA = pmin(Food00, 7) * 2 +               
          pmin(Food_bneed_a, 7) * 4 +         
          pmin(Food_div1, 7) * 4 +            
          pmin(Final_01, 7) * 4 +             
          pmin(food_number_of_days, 7) * 2    
  )


summary(Food$SCA)



```
                          
                   C.Tableau des poids par groupe alimentaire
```{r echo=TRUE, message=FALSE, warning=FALSE}

poids <- data.frame(
  Groupe = c("Food00", "Food_bneed_a", "Food_div1", "Final_01", "food_number_of_days"),
  Poids = c(2, 4, 4, 4, 2)
)

poids
sum(poids$Poids)

```
            d.Catégorisation du SCA selon deux types de seuils
            
                              Seuils 1 :
                              
    0–21 = pauvre, 21.5–35 = limite, >35 = acceptable

                             Seuils 2 :
                             
           0–28 = pauvre, 28.5–42 = limite, >42 = acceptable 
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Seuils 21/35
Food <- Food %>%
  mutate(SCA_cat_21 = case_when(
    SCA <= 21 ~ "Pauvre",
    SCA > 21 & SCA <= 35 ~ "Limite",
    SCA > 35 ~ "Acceptable"
  ))

# Seuils 28/42
Food <- Food %>%
  mutate(SCA_cat_28 = case_when(
    SCA <= 28 ~ "Pauvre",
    SCA > 28 & SCA <= 42 ~ "Limite",
    SCA > 42 ~ "Acceptable"
  ))

table(Food$SCA_cat_21)
table(Food$SCA_cat_28)

```
       e.Représentation spatiale (par région et département)
       
           Agrégation des scores par région/département  
```{r echo=TRUE, message=FALSE, warning=FALSE}

Base_Complete <- bind_cols(Base_Principale, Food)

sca_dept <- Base_Complete %>%
  group_by(Base_Complete$admin2) %>%
  summarise(SCA_moy=mean(SCA, na.rm = TRUE),
            cat_21 = names(which.max(table(Food$SCA_cat_21))),
            cat_28 = names(which.max(table(Food$SCA_cat_28))))











```
           

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
