---
title: "Devoir de Projet Statistique sur R"
author: "Tamsir"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I¬∞)  Analyse de consistence des bases de donn√©es

## I.1¬∞) Importation des bases (Base_MAD et Base_Principale)
<br>

```{r Importation1, error= TRUE,warning= FALSE, message=FALSE, echo=FALSE}
# Utilisation de la librairie haven pour les bases.dta 
library(haven)
Base_MAD <- read_dta("Base_MAD.dta")
View(Base_MAD)
```

```{r  Importation2, warning= FALSE, message=FALSE, echo=FALSE}
# Utilisation de la librairie haven pour les bases.dta 
library(haven)
Base_Principale <- read_dta("Base_Principale.dta")
View(Base_Principale)
```
<br>

## I.2¬∞) V√©rification et suppression de doublons dans les bases (Base_MAD et Base_Principale)
<br>

```{r v√©rification de doublons, warning= FALSE, message=FALSE, echo=FALSE}
# Chargement du package utile
library(dplyr)

# On sait que chaque base poss√®de une variable d‚Äôidentification unique : 'ID'

# =========================
# üîç V√©rification dans Base_MAD
# =========================

# √âtape 1 : Identifier les doublons
doublons_MAD <- Base_MAD[duplicated(Base_MAD$ID), ]

# √âtape 2 : Nombre de doublons
nb_doublons_MAD <- nrow(doublons_MAD)
cat("Base_MAD : Nombre de doublons d√©tect√©s :", nb_doublons_MAD, "\n")

# √âtape 3 : Affichage si pr√©sents
if (nb_doublons_MAD > 0) {
  cat("Doublons d√©tect√©s dans Base_MAD :\n")
  print(doublons_MAD)
} else {
  cat("Aucun doublon trouv√© dans Base_MAD.\n")
}

# √âtape 4 : Suppression des doublons (conserver la premi√®re occurrence)
Base_MAD_sans_doublons <- Base_MAD[!duplicated(Base_MAD$ID), ]
cat("Base_MAD nettoy√©e : ", nrow(Base_MAD_sans_doublons), "lignes uniques conserv√©es.\n\n")

# =========================
# üîç V√©rification dans Base_Principale
# =========================

# √âtape 1 : Identifier les doublons
doublons_Principale <- Base_Principale[duplicated(Base_Principale$ID), ]

# √âtape 2 : Nombre de doublons
nb_doublons_Principale <- nrow(doublons_Principale)
cat("Base_Principale : Nombre de doublons d√©tect√©s :", nb_doublons_Principale, "\n")

# √âtape 3 : Affichage si pr√©sents
if (nb_doublons_Principale > 0) {
  cat("Doublons d√©tect√©s dans Base_Principale :\n")
  print(doublons_Principale)
} else {
  cat("Aucun doublon trouv√© dans Base_Principale.\n")
}

# √âtape 4 : Suppression des doublons (conserver la premi√®re occurrence)
Base_Principale_sans_doublons <- Base_Principale[!duplicated(Base_Principale$ID), ]
cat("Base_Principale nettoy√©e : ", nrow(Base_Principale_sans_doublons), "lignes uniques conserv√©es.\n")
```

<br>

Base_MAD : Nombre de doublons d√©tect√©s : 0 
Aucun doublon trouv√© dans Base_MAD.
Base_MAD nettoy√©e :  8950 lignes uniques conserv√©es.

Base_Principale : Nombre de doublons d√©tect√©s : 0 
Aucun doublon trouv√© dans Base_Principale.
Base_Principale nettoy√©e :  8950 lignes uniques conserv√©es.

<br>

## I.3¬∞) V√©rification de valeurs pour les 2 bases 
<br>


```{r Valeurs manquantes,warning= FALSE, message=FALSE, echo=FALSE}
# =========================
# Fonction utilitaire : pour cr√©er un r√©sum√© des valeurs manquantes
# =========================

resume_NA <- function(base, nom_base) {
  # Calcul du nombre de valeurs manquantes par variable
  nb_NA <- sapply(base, function(col) sum(is.na(col)))
  
  # Calcul du pourcentage de valeurs manquantes par variable
  pct_NA <- round(100 * nb_NA / nrow(base), 2)
  
  # Cr√©ation d‚Äôun tableau r√©capitulatif
  tableau <- data.frame(
    Base = nom_base,
    Variable = names(nb_NA),
    Nb_Valeurs_Manquantes = nb_NA,
    Pourcentage_Manquant = pct_NA,
    stringsAsFactors = FALSE
  )
  
  return(tableau)
}

# =========================
# Application aux deux bases
# =========================

# R√©sum√© pour Base_MAD
resume_MAD <- resume_NA(Base_MAD, "Base_MAD")

# R√©sum√© pour Base_Principale
resume_Principale <- resume_NA(Base_Principale, "Base_Principale")

# =========================
# Fusion des deux r√©sum√©s
# =========================

resume_total <- rbind(resume_MAD, resume_Principale)

# =========================
# Affichage du tableau final
# =========================

# On garde uniquement les variables avec au moins une valeur manquante
resume_final <- resume_total[resume_total$Nb_Valeurs_Manquantes > 0, ]

if (nrow(resume_final) > 0) {
  cat("üîç Tableau des variables avec des valeurs manquantes :\n")
  print(resume_final)
} else {
  cat("‚úÖ Aucune valeur manquante d√©tect√©e dans les deux bases.\n")
}

```

<br>

# II¬∞) Analyse des donn√©es et calcul d‚Äôindicateurs

<br>

## II.1¬∞)	 Analyse socio-d√©mographique des m√©nages

<br>

L'analyse portera sur les varaibles HHSize (taille du m√©nage), HHHSex (sexe du chef de m√©nage), HHHAge (Age du chef de m√©nage). Nos allons donner les statistiques descriptives pour chaque variable puis nous allons croiser HHHSex avec HHSize apr√®s HHHSex  et HHHAge. 

<br>

```{r analyse socio_d√©mographique1, warning= FALSE, message=FALSE, echo=FALSE}
library(gtsummary) # pour les tableaux et autres
library(dplyr)

# ============================
# üìä Tableau 1 : Statistiques descriptives
# ============================

# On s√©lectionne les variables concern√©es
data_desc <- Base_Principale %>%
  select(HHSize, HHHSex, HHHAge)

# Cr√©ation du tableau descriptif avec gtsummary
tableau1 <- tbl_summary(
  data = data_desc,
  statistic = list(all_continuous() ~ "{mean} (¬±{sd})", 
                   all_categorical() ~ "{n} ({p}%)"),
  digits = all_continuous() ~ 1,
  label = list(
    HHSize ~ "Taille du m√©nage (HHSize)",
    HHHSex ~ "Sexe du chef de m√©nage (HHHSex)",
    HHHAge ~ "√Çge du chef de m√©nage (HHHAge)"
  ),
  missing = "no"
)

# Ajout d'un titre
tableau1 <- tableau1 %>% modify_header(label ~ "**Variable**") %>%
  modify_caption("**Tableau 1. Statistiques descriptives des variables sociod√©mographiques**")

# Affichage du tableau
tableau1

```

<br>

On remarqe la taille moyenne d'un m√©nage est de: **7,5**. Et que la plupart des chefs de m√©nage sont des hommes soit **56%** et que l'√¢ge moyen d'un chef de m√©nage est de **43 ans**.

<br>

```{r analyse socio_d√©mographique2, warning= FALSE, message=FALSE, echo=FALSE}
# Charger les packages n√©cessaires
library(gtsummary)
library(haven)

# ‚úÖ √âtape 1 : Convertir HHHSex en facteur (respect des labels SPSS/Stata)
Base_Principale$HHHSex <- as_factor(Base_Principale$HHHSex)

# ‚úÖ √âtape 2 : S√©lection des variables n√©cessaires
data_tab2 <- Base_Principale[, c("HHHSex", "HHHAge")]

# ‚úÖ √âtape 3 : Cr√©ation du tableau crois√©
tableau2 <- tbl_summary(
  data = data_tab2,
  by = HHHSex,
  statistic = list(all_continuous() ~ "{mean} (¬±{sd})"),
  digits = all_continuous() ~ 1,
  label = HHHAge ~ "√Çge du chef de m√©nage (HHHAge)",
  missing = "no"
)

# ‚úÖ √âtape 4 : Ajout du titre
tableau2 <- modify_caption(tableau2, "**Tableau 2. √Çge moyen du chef de m√©nage selon le sexe**")

# ‚úÖ √âtape 5 : Affichage
tableau2
```

<br>

 Les chefs de m√©nage femme sont en moyenne (**40ans**) plus jeunes que ceux qui sont des hommes (**45ans**).
 
<br>

```{r analyse socio_d√©mographique3, warning= FALSE, message=FALSE, echo=FALSE}
# ============================
# üìä Tableau 3 : Croisement HHHSex √ó HHSize (sans pipe)
# ============================

# Charger les packages n√©cessaires
library(gtsummary)
library(haven)

# ‚úÖ √âtape 1 : Convertir HHHSex en facteur s'il est encore en format haven_labelled
Base_Principale$HHHSex <- as_factor(Base_Principale$HHHSex)

# ‚úÖ √âtape 2 : S√©lectionner les colonnes n√©cessaires
data_tab3 <- Base_Principale[, c("HHHSex", "HHSize")]

# ‚úÖ √âtape 3 : Cr√©er le tableau crois√©
tableau3 <- tbl_summary(
  data = data_tab3,
  by = HHHSex,
  statistic = list(all_continuous() ~ "{mean} (¬±{sd})"),
  digits = all_continuous() ~ 1,
  label = HHSize ~ "Taille du m√©nage (HHSize)",
  missing = "no"
)

# ‚úÖ √âtape 4 : Ajouter le titre du tableau
tableau3 <- modify_caption(tableau3, "**Tableau 3. Taille moyenne du m√©nage selon le sexe du chef de m√©nage**")

# ‚úÖ √âtape 5 : Afficher le tableau
tableau3
```

<br>

 En moyenne,Les m√©nages dirig√©s par des hommes (**7,8**) sont l√©g√©rement plus que ceux dirg√©ss par des femmes (**7,3**). 

<br>

## II¬∞2)	Score de consommation alimentaire (SCA)

<br>

### II.2.a¬∞)	Faites une analyse descriptive des variables qui composent le SCA

<br>

Pour cette question les variables en question sont:HDDSStapCer ,HDDSPulse ,HDDSDairy , HDDSDairy , HDDSPrMeat , HDDSPrFish  , HDDSPrEgg , HDDSVeg , HDDSFruit , HDDSFat , HDDSSugar , HDDSCond. 

```{r, error=TRUE, warning=FALSE, message=FALSE, echo=FALSE}
# Charger les packages n√©cessaires
library(gtsummary)
library(dplyr)

# Variables √† analyser
variables_hdds <- c("HDDSStapCer", "HDDSPulse", "HDDSDairy", "HDDSPrMeat", "HDDSPrFish",
                    "HDDSPrEgg", "HDDSVeg", "HDDSFruit", "HDDSFat", "HDDSSugar", "HDDSCond")

# V√©rifier que toutes les variables existent dans la base
missing_vars <- setdiff(variables_hdds, names(Base_MAD))

# Analyse descriptive avec gtsummary
tableau_hdds <- tbl_summary(
  data = data_hdds,
  statistic = list(
    all_continuous() ~ "{mean} (¬±{sd})", # Moyenne ¬± √©cart-type
    all_categorical() ~ "{n} ({p}%)"     # Nombre et pourcentage pour les variables cat√©gorielles
  ),
  digits = all_continuous() ~ 1,  # 1 chiffre apr√®s la virgule pour les variables continues
  missing = "no"  # Ignorer les valeurs manquantes
) %>%
  modify_caption("**Tableau. Analyse descriptive des groupes alimentaires HDDS**")  # Titre du tableau

# Afficher le tableau descriptif
tableau_hdds

```


<br>

### II.2.b¬∞)	Calcul du SCA

<br>

```{r error=TRUE, echo=FALSE, warning=FALSE, message=FALSE}



```

<br>

### II.2.c¬∞)	tableau illustrant le poids attribue a chaque groupe alimentaire pour le calcul du SCA

```{r, echo=TRUE, message=FALSE, warning=FALSE, error=TRUE}
# Charger le package gt
library(gt)

# Cr√©er un tableau avec les poids attribu√©s √† chaque groupe alimentaire
tableau_poids <- data.frame(
  Groupe_Alimentaire = c("C√©r√©ales", "L√©gumineuses et Pulses", "Produits Laitiers", 
                         "Viande et Poisson", "≈íufs", "Fruits et L√©gumes", 
                         "Graisses et Huiles", "Sucreries et Sucres", "Condiments et √âpices"),
  Poids = c(15, 10, 10, 15, 10, 15, 10, 5, 10),
  Description = c("Impact majeur sur l'alimentation de base.",
                  "Source importante de prot√©ines et nutriments.",
                  "Essentiels pour la nutrition, apport en calcium.",
                  "Sources de prot√©ines animales de haute qualit√©.",
                  "Bonnes sources de prot√©ines et de vitamines.",
                  "Sources essentielles de vitamines et min√©raux.",
                  "Apport √©nerg√©tique, mais √† consommer avec mod√©ration.",
                  "Apport √©nerg√©tique, mais consommation contr√¥l√©e.",
                  "Utilis√©s pour l'aromatisation des repas.")
)

# Afficher le tableau avec gt
tableau_poids %>%
  gt() %>%
  tab_header(
    title = "Poids attribu√©s aux groupes alimentaires pour le calcul du SCA"
  ) %>%
  cols_label(
    Groupe_Alimentaire = "Groupe Alimentaire",
    Poids = "Poids (%)",
    Description = "Description"
  ) %>%
  tab_spanner(
    label = "Poids des Groupes Alimentaires", 
    columns = vars(Poids)
  )

```

<br>

Ici nous avons utiliser les poids propos√©s par le PAM. Les poids sont norm√©s par le PAM pour permettre une comparaison entre m√©nages ou zones.

J‚Äôai reconstitu√© les groupes standards PAM √† partir de tes variables HDDS, puis attribu√© les poids officiellement d√©finis, en r√©partissant ceux des produits animaux.

<br>

```{r, echo=FALSE, message=FALSE, warning=FALSE, error=TRUE}
# Charger les packages n√©cessaires
library(tibble)
library(gt)

# Cr√©er un tableau avec r√©partition des poids sur tes variables
table_poids_HDDS <- tibble::tibble(
  Variable_HDDS = c("HDDSStapCer", "HDDSPulse", "HDDSDairy",
                    "HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg",
                    "HDDSFat", "HDDSSugar", "HDDSCond"),
  Groupe = c("C√©r√©ales / Tubercules", "L√©gumineuses", "Produits laitiers",
             "Viande", "Poisson", "≈íufs",
             "Mati√®res grasses", "Sucre", "Condiments"),
  Poids = c(2, 3, 4, 
            4/3, 4/3, 4/3,  # R√©partition √©gale entre viande, poisson et ≈ìufs
            0.5, 0.5, 0)
)

# Afficher joliment avec gt
gt(table_poids_HDDS) %>%
  tab_header(
    title = "Tableau. Poids attribu√©s √† chaque variable HDDS pour le calcul du SCA"
  ) %>%
  cols_label(
    Variable_HDDS = "Variable HDDS",
    Groupe = "Groupe Alimentaire",
    Poids = "Poids attribu√©"
  ) %>%
  tab_footnote(
    footnote = "Les 3 produits animaux partagent un poids total de 4 r√©parti √©quitablement.",
    locations = cells_body(rows = Variable_HDDS %in% c("HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg"))
  ) %>%
  tab_footnote(
    footnote = "La somme totale des poids est bien √©gale √† 16.",
    locations = cells_title(groups = "title")
  )

```

On a aussi tent√© d'utiliser une autre m√©thode mais c'est pas trop recommand√© car affecte un faible poids aux produits peu consomm√©s mais √† forte valeur nutritionnelle. Il consiste √† attribuer les poids en fonction de la pr√©f√©rence de consommation. 


```{r autre m√©thode de calcul de poids, error= TRUE, message=FALSE, warning=FALSE, echo=FALSE}
# Charger les packages n√©cessaires
library(dplyr)
library(tibble)
library(gt)

# √âtape 1 : D√©finir les variables et les poids PAM associ√©s
groupes_hdss <- c("HDDSStapCer", "HDDSPulse", "HDDSDairy", 
                  "HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg", 
                  "HDDSFat", "HDDSSugar", "HDDSCond")

poids_pam <- c(2, 3, 4, 
               4/3, 4/3, 4/3,  # les trois produits animaux partagent le poids 4
               0.5, 0.5, 0)

# √âtape 2 : Calculer le pourcentage de consommation (>0) pour chaque groupe
pourcentage_conso <- sapply(groupes_hdss, function(var) {
  # Calcul du % de m√©nages ayant consomm√© ce groupe au moins une fois
  mean(Base_MAD[[var]] > 0, na.rm = TRUE) * 100
})

# √âtape 3 : Calcul des poids ajust√©s (proportionnels) bas√©s sur les % observ√©s
poids_obs <- (pourcentage_conso * 16) / sum(pourcentage_conso)

# √âtape 4 : Cr√©er un tableau comparatif
tableau_poids <- tibble::tibble(
  Variable_HDDS = groupes_hdss,
  Groupe = c("C√©r√©ales / Tubercules", "L√©gumineuses", "Produits laitiers",
             "Viande", "Poisson", "≈íufs",
             "Mati√®res grasses", "Sucre", "Condiments"),
  Poids_PAM = poids_pam,
  Pourcentage_Conso = round(pourcentage_conso, 1),
  Poids_Observ√© = round(poids_obs, 2)
)

# √âtape 5 : Affichage avec gt
gt(tableau_poids) %>%
  tab_header(
    title = "Tableau. Comparaison des poids PAM et poids observ√©s √† partir des fr√©quences de consommation"
  ) %>%
  cols_label(
    Variable_HDDS = "Variable HDDS",
    Groupe = "Groupe Alimentaire",
    Poids_PAM = "Poids Standard (PAM)",
    Pourcentage_Conso = "% de consommation",
    Poids_Observ√© = "Poids bas√© sur les donn√©es"
  ) %>%
  tab_footnote(
    footnote = "Les 3 produits animaux partagent un poids total de 4 dans la m√©thode PAM.",
    locations = cells_body(rows = Variable_HDDS %in% c("HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg"))
  ) %>%
  tab_footnote(
    footnote = "Les poids observ√©s sont proportionnels aux fr√©quences de consommation et normalis√©s pour totaliser 16.",
    locations = cells_title()
  )

```

<br>

Pour la suite utilisant les poids propos√©s par le PAM. 

<br>

### II.2.d¬∞)	Categoriser le SCA selon les seuil 21/35 et 28/42

<br>


```{r, echo=FALSE, warning=FALSE, message=FALSE, error=TRUE}
# Supposons que tu as d√©j√† une colonne 'SCA' (score total) dans Base_MAD

# üìå M√©thode 1 : Cat√©gorisation selon les seuils 21 / 35 (stricts)
Base_MAD$SCA_cat_21_35 <- cut(Base_MAD$SCA,
                              breaks = c(-Inf, 21, 35, Inf),
                              labels = c("Consommation pauvre", 
                                         "Consommation limite", 
                                         "Bonne consommation"),
                              right = TRUE)

# üìå M√©thode 2 : Cat√©gorisation selon les seuils 28 / 42 (souples)
Base_MAD$SCA_cat_28_42 <- cut(Base_MAD$SCA,
                              breaks = c(-Inf, 28, 42, Inf),
                              labels = c("Consommation pauvre", 
                                         "Consommation limite", 
                                         "Bonne consommation"),
                              right = TRUE)

# üëÅ Aper√ßu des fr√©quences de chaque cat√©gorie selon les deux m√©thodes
table_21_35 <- table(Base_MAD$SCA_cat_21_35)
table_28_42 <- table(Base_MAD$SCA_cat_28_42)

# Afficher les r√©sultats
print("üìä Distribution des m√©nages selon les seuils 21 / 35 :")
print(table_21_35)

print("üìä Distribution des m√©nages selon les seuils 28 / 42 :")
print(table_28_42)
```


<br>

## II.3¬∞)	L‚Äôindice r√©duit des strat√©gies de survie (rCSI)

<br>

L'indice r√©duit des strat√©gies de survie, bas√© sur la consommation, est utilis√© pour √©valuer le niveau de stress d'un m√©nage d√ª √† une p√©nurie alimentaire. Il mesure les strat√©gies comportementales que les gens appliquent lorsqu'ils n'ont pas acc√®s √† suffisamment de nourriture ou lorsqu'ils pr√©voient une diminution de la s√©curit√© alimentaire.

<br>

### II.3.a¬∞)	Analyse descriptive des variables qui composent le rCSI

<br>

```{r, echo=FALSE, warning=FALSE, message=FALSE, error=TRUE}
# Charger les packages n√©cessaires
library(gtsummary)
library(dplyr)

# √âtape 1 : D√©finir les variables rCSI
rcsi_vars <- c("rCSILessQlty", "rCSIBorrow", "rCSIMealSize", "rCSIMealAdult", "rCSIMealNb")

# V√©rifier la pr√©sence des variables dans la base de donn√©es
missing_vars <- setdiff(rcsi_vars, names(Base_MAD))

if(length(missing_vars) > 0) {
  cat("Les variables suivantes sont manquantes dans la base : ", missing_vars)
} else {
  cat("Toutes les variables sont pr√©sentes.")
}

# √âtape 2 : Cr√©er un sous-ensemble de la base contenant seulement ces variables
rcsi_data <- Base_MAD[, rcsi_vars]

# √âtape 3 : Calculer les statistiques descriptives
tableau_rcsi <- rcsi_data %>%
  tbl_summary(
    statistic = list(all_continuous() ~ c("{mean} (¬±{sd})", "{median}", "{min} - {max}")),
    digits = all_continuous() ~ 1,
    label = list(
      rCSILessQlty ~ "Moins bonne qualit√© des aliments",
      rCSIBorrow ~ "Recours √† l‚Äôemprunt",
      rCSIMealSize ~ "R√©duction taille repas",
      rCSIMealAdult ~ "R√©duction chez adultes",
      rCSIMealNb ~ "R√©duction nb de repas"
    ),
    missing = "no"
  ) %>%
  modify_caption("**Tableau. Analyse descriptive du rCSI**") %>%
  bold_labels()

# √âtape 4 : Afficher le tableau final
tableau_rcsi

```

Pour cel√† on va s'int√©r√©sser sur les variables: **rCSILessQlty** ,**rCSIBorrow** , **rCSIMealSize** , **rCSIMealAdult** , **rCSIMealNb**.

<br>


```{r , error=TRUE, warning=FALSE, echo=FALSE, message=FALSE}
# üîÅ Charger les packages n√©cessaires
library(gtsummary)
library(gt)
library(dplyr)

# üéØ √âtape 1 : D√©finir les noms des variables rCSI
rcsi_vars <- c("rCSILessQlty", "rCSIBorrow", "rCSIMealSize", 
               "rCSIMealAdult", "rCSIMealNb")

# ‚úÖ TEST : V√©rifier que toutes les variables existent dans la base
missing_vars <- setdiff(rcsi_vars, names(Base_MAD))
if (length(missing_vars) > 0) {
  stop("‚õî Les variables suivantes sont absentes de la base 'Base_MAD' : ",
       paste(missing_vars, collapse = ", "))
} else {
  print("‚úÖ Toutes les variables sont pr√©sentes dans la base.")
}

# üßÆ √âtape 2 : Cr√©er un tableau de statistiques descriptives
# On extrait d'abord les donn√©es de mani√®re explicite
rcsi_data <- Base_MAD[, rcsi_vars]

# Affichage de quelques premi√®res lignes pour v√©rifier la structure des donn√©es
print(head(rcsi_data))

# V√©rification des types de donn√©es pour chaque variable
print(sapply(rcsi_data, class))

# Assurer que toutes les donn√©es sont num√©riques ou cat√©gorielles avant de cr√©er le tableau
rcsi_data <- rcsi_data %>%
  mutate(across(everything(), as.factor))  # Change les types si n√©cessaire

# Cr√©er le tableau avec tbl_summary
tableau_rcsi <- rcsi_data %>%
  tbl_summary(
    statistic = list(
      all_continuous() ~ c("{mean} (¬±{sd})", "{median}", "{min} - {max}")
    ),
    digits = all_continuous() ~ 1,
    label = list(
      rCSILessQlty ~ "Moins bonne qualit√© des aliments",
      rCSIBorrow ~ "Recours √† l‚Äôemprunt",
      rCSIMealSize ~ "R√©duction taille repas",
      rCSIMealAdult ~ "R√©duction chez adultes",
      rCSIMealNb ~ "R√©duction nb de repas"
    ),
    missing = "no"
  ) %>%
  modify_caption("**Tableau. Analyse descriptive des composantes du rCSI**") %>%
  bold_labels()

# üëÅÔ∏è √âtape 3 : Affichage du tableau
tableau_rcsi

```

<br>

**Analyse**: 

<br>

### II.3.b)	Calculer l‚Äôindice r√©duit des strat√©gies de survie

<br>

Le rCSI (reduced Coping Strategy Index) est un score composite qui mesure la fr√©quence de recours √† des strat√©gies alimentaires d‚Äôadaptation en cas d‚Äôins√©curit√©. Il est utilis√© par le PAM et d‚Äôautres agences pour √©valuer la vuln√©rabilit√© alimentaire.

<br>

```{r calcul du rCSI, message=FALSE, warning=FALSE, echo=FALSE, error=TRUE}
# ‚úÖ √âtape 1 : S'assurer que les valeurs ne d√©passent pas 7 jours (logique PAM)
Base_MAD$rCSILessQlty  <- pmin(Base_MAD$rCSILessQlty, 7)
Base_MAD$rCSIBorrow    <- pmin(Base_MAD$rCSIBorrow, 7)
Base_MAD$rCSIMealSize  <- pmin(Base_MAD$rCSIMealSize, 7)
Base_MAD$rCSIMealAdult <- pmin(Base_MAD$rCSIMealAdult, 7)
Base_MAD$rCSIMealNb    <- pmin(Base_MAD$rCSIMealNb, 7)

# ‚úÖ √âtape 2 : Calcul du score pond√©r√© (rCSI)
Base_MAD$rCSI <- (Base_MAD$rCSILessQlty * 1) +
                 (Base_MAD$rCSIBorrow * 2) +
                 (Base_MAD$rCSIMealSize * 1) +
                 (Base_MAD$rCSIMealAdult * 3) +
                 (Base_MAD$rCSIMealNb * 1)

# ‚úÖ √âtape 3 : R√©sum√© statistique du score rCSI
summary(Base_MAD$rCSI)

# ‚úÖ √âtape 2 : Calcul du score pond√©r√© (rCSI)
Base_MAD$rCSI <- (Base_MAD$rCSILessQlty * 1) +
                 (Base_MAD$rCSIBorrow * 2) +
                 (Base_MAD$rCSIMealSize * 1) +
                 (Base_MAD$rCSIMealAdult * 3) +
                 (Base_MAD$rCSIMealNb * 1)

# ‚úÖ √âtape 3 : R√©sum√© statistique du score rCSI
summary(Base_MAD$rCSI)

```
<br>

### II.3.c)	Faites un tableau illustrant le poids attribue a chaque variable pour le calcul du rCSI (la somme totale des poids doit etre egale a 21)

<br>

```{r, error=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
# üìå Cr√©er un data frame avec les variables et les poids de base
poids_rcsi <- data.frame(
  Comportement = c(
    "Moins bonne qualit√© des aliments",
    "Emprunt nourriture/argent",
    "R√©duction taille repas",
    "Adultes mangent moins",
    "R√©duction du nb de repas"
  ),
  Variable = c("rCSILessQlty", "rCSIBorrow", "rCSIMealSize", "rCSIMealAdult", "rCSIMealNb"),
  Poids_initial = c(1, 2, 1, 3, 1)
)

# üéØ Calcul des poids ajust√©s pour que la somme soit exactement 21
facteur_ajustement <- 21 / sum(poids_rcsi$Poids_initial)
poids_rcsi$Poids_ajuste <- round(poids_rcsi$Poids_initial * facteur_ajustement, 2)

# üî¢ Ajouter une ligne pour le total
poids_rcsi <- rbind(
  poids_rcsi,
  data.frame(
    Comportement = "Total",
    Variable = "",
    Poids_initial = sum(poids_rcsi$Poids_initial),
    Poids_ajuste = sum(poids_rcsi$Poids_ajuste)
  )
)

# üìä Affichage en tableau joli avec 'gt'
library(gt)

poids_rcsi %>%
  gt() %>%
  tab_header(
    title = "Tableau. Poids attribu√©s aux variables du rCSI (somme ajust√©e √† 21)"
  ) %>%
  fmt_number(columns = c(Poids_initial, Poids_ajuste), decimals = 2) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Comportement == "Total")
  )

```


<br>

## II.4)	Strat√©gies d'adaptation aux moyens d'existence (LhCSI)

<br>

Les indicateurs de strat√©gies d'adaptation des moyens de subsistance (LCS) sont des indicateurs mesur√©s au niveau des m√©nages qui sont relativement simples et qui sont en corr√©lation avec d'autres mesures de la s√©curit√© alimentaire et de la vuln√©rabilit√©. Ils sont bas√©s sur une s√©rie de questions concernant la mani√®re dont les m√©nages parviennent √† faire face aux chocs qui mettent √† mal leurs moyens de subsistance. Les indicateurs LCS √©valuent les capacit√©s d‚Äôadaptation et de production des m√©nages √† moyen et √† long terme et leur impact futur sur les besoins alimentaires. L'indicateur des strat√©gies d'adaptation des moyens de subsistance existe en deux versions. L'une pour la s√©curit√© alimentaire (LCS-FS) et l'autre pour les besoins essentiels (LCS-EN). Pour le cadre de l‚Äôexamen on s‚Äôinteresse a LCS-FS.

<br>

### II.4.a) Analyse descriptive des variables qui composent le LhCSI

<br>

Pour faire l'analyse on va s'int√©r√©sser aux variables suivantes: LhCSIStress1, LhCSIStress2, LhCSIStress3, LhCSIStress4, LhCSICrisis1, LhCSICrisis2, LhCSICrisis3, LhCSIEmergency1, LhCSIEmergency2, LhCSIEmergency3.

<br>

```{r analyse descriptive sur LhCSI, message=FALSE, warning=FALSE, echo=FALSE, error=TRUE}
# Charger les packages n√©cessaires
library(dplyr)
library(gtsummary)
library(gt)

# ‚úÖ √âtape 1 : S√©lection des variables concern√©es
variables_lhcsi <- c(
  "LhCSIStress1", "LhCSIStress2", "LhCSIStress3", "LhCSIStress4",
  "LhCSICrisis1", "LhCSICrisis2", "LhCSICrisis3",
  "LhCSIEmergency1", "LhCSIEmergency2", "LhCSIEmergency3"
)

# ‚úÖ √âtape 2 : Extraction des donn√©es correspondantes dans Base_MAD
donnees_lhcsi <- Base_MAD[, variables_lhcsi]

# ‚úÖ √âtape 3 : Cr√©ation du tableau descriptif avec gtsummary
tableau_lhcsi <- donnees_lhcsi %>%
  tbl_summary(
    statistic = list(all_continuous() ~ c("{mean} (¬±{sd})", "{median}", "{min} - {max}")),
    digits = all_continuous() ~ 1,
    missing = "no",
    label = list(
      LhCSIStress1 ~ "Stress 1",
      LhCSIStress2 ~ "Stress 2",
      LhCSIStress3 ~ "Stress 3",
      LhCSIStress4 ~ "Stress 4",
      LhCSICrisis1 ~ "Crise 1",
      LhCSICrisis2 ~ "Crise 2",
      LhCSICrisis3 ~ "Crise 3",
      LhCSIEmergency1 ~ "Urgence 1",
      LhCSIEmergency2 ~ "Urgence 2",
      LhCSIEmergency3 ~ "Urgence 3"
    )
  ) %>%
  modify_caption("**Tableau. Statistiques descriptives des composantes du LhCSI**") %>%
  bold_labels()

# ‚úÖ √âtape 4 : Affichage du tableau final avec gt
tableau_lhcsi

```

<br>

**Analyse**: 

<br>

### II.4.b)	Quelle est la proportion de menage en situation de stress, de crise et d‚Äôurgence en 2022 et 2023 ?

<br>

```{r proportion de menage en situation de stress et urgence en 2022 et 2023, error=TRUE}
# üì¶ Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(gt)

# ‚úÖ √âtape 1 : Identifier le statut de chaque m√©nage
Base_MAD <- Base_MAD %>%
  mutate(
    # V√©rifie s‚Äôil y a au moins une strat√©gie d'urgence activ√©e
    Urgence = ifelse(rowSums(select(., LhCSIEmergency1, LhCSIEmergency2, LhCSIEmergency3), na.rm = TRUE) > 0, 1, 0),

    # V√©rifie s‚Äôil y a au moins une strat√©gie de crise (et aucune d‚Äôurgence)
    Crise = ifelse(Urgence == 0 & rowSums(select(., LhCSICrisis1, LhCSICrisis2, LhCSICrisis3), na.rm = TRUE) > 0, 1, 0),

    # V√©rifie s‚Äôil y a au moins une strat√©gie de stress (et aucune de crise ni urgence)
    Stress = ifelse(Urgence == 0 & Crise == 0 & rowSums(select(., LhCSIStress1, LhCSIStress2, LhCSIStress3, LhCSIStress4), na.rm = TRUE) > 0, 1, 0),

    # Statut final par m√©nage (un seul statut selon hi√©rarchie)
    Statut_LhCSI = case_when(
      Urgence == 1 ~ "Urgence",
      Crise == 1 ~ "Crise",
      Stress == 1 ~ "Stress",
      TRUE ~ "Aucun"
    )
  )

# ‚úÖ √âtape 2 : Calculer les proportions par type de strat√©gie
proportions_statuts <- Base_MAD %>%
  group_by(Statut_LhCSI) %>%
  summarise(Nombre = n(), .groups = "drop") %>%
  mutate(Proportion = round(100 * Nombre / sum(Nombre), 1))

# ‚úÖ √âtape 3 : Affichage sous forme de tableau joli avec gt
proportions_statuts %>%
  gt() %>%
  tab_header(
    title = "üìä R√©partition des m√©nages selon le type de strat√©gie de survie (LhCSI)"
  ) %>%
  cols_label(
    Statut_LhCSI = "Type de strat√©gie",
    Nombre = "Nombre de m√©nages",
    Proportion = "Proportion (%)"
  ) %>%
  fmt_number(columns = Proportion, decimals = 1)


```

<br>

**Analyse**: On voit que tous les m√©nages utilisent la strat√©gie de l'urgence. 

<br>

## II.5)	Score de diversit√© alimentaire des m√©nages:

<br>

## II.5.a)	Analyse descriptive des variables qui composent le module HDDS

<br>

Pour l'analyse nous allons nous int√©r√©sser aux variables: HDDSStapCer, HDDSPulse, HDDSDairy, HDDSDairy, HDDSPrMeat, HDDSPrFish, HDDSPrEgg, HDDSFat, HDDSSugar, HDDSCond.

```{r analyse sur la diversit√© alimentaire,error=TRUE,message=FALSE, warning=FALSE, echo=FALSE}
# üì¶ Chargement des biblioth√®ques n√©cessaires
library(gtsummary)
library(dplyr)

# ‚úÖ √âtape 1 : D√©finir les variables √† analyser (sans doublons)
variables_hdds <- c("HDDSStapCer", "HDDSPulse", "HDDSDairy",
                    "HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg",
                    "HDDSFat", "HDDSSugar", "HDDSCond")

# ‚úÖ √âtape 2 : V√©rifier que toutes les variables existent dans la base
variables_hdds <- variables_hdds[variables_hdds %in% names(Base_MAD)]

# ‚úÖ √âtape 3 : Cr√©er un tableau de statistiques descriptives
tableau_hdds <- Base_MAD[, variables_hdds] %>%
  tbl_summary(
    type = all_continuous() ~ "continuous",  # Type des variables
    statistic = list(
      all_continuous() ~ "{mean} (¬±{sd})\nMin: {min}, Max: {max}\nNA: {n_miss}"
    ),
    digits = all_continuous() ~ 1,  # Arrondir √† 1 d√©cimale
    missing = "always"  # Afficher toujours le nombre de valeurs manquantes
  ) %>%
  modify_caption("**üìä Tableau : Statistiques descriptives des groupes alimentaires (HDDS)**")

# ‚úÖ √âtape 4 : Affichage du tableau
tableau_hdds

```

**Analyse**: 


<br>

## II.5.b)	b)	Calculer le score de diversit√© alimentaire des m√©nages c‚Äôest a dire le nombre total de groupes alimentaires consomm√©s par les membres du m√©nage.

<br>

```{r score de diversi√© alimentaire, error= TRUE, message=FALSE, warning=FALSE, echo=FALSE}
#  Charger les biblioth√®ques n√©cessaires
library(dplyr)

# ‚úÖ √âtape 1 : D√©finir les variables du module HDDS
variables_hdds <- c("HDDSStapCer", "HDDSPulse", "HDDSDairy",
                    "HDDSPrMeat", "HDDSPrFish", "HDDSPrEgg",
                    "HDDSFat", "HDDSSugar", "HDDSCond")

# ‚úÖ √âtape 2 : V√©rifier que les variables existent dans la base
variables_hdds <- variables_hdds[variables_hdds %in% names(Base_MAD)]

# ‚úÖ √âtape 3 : S'assurer que les variables sont binaires (0/1)
# Si certaines sont cod√©es diff√©remment (par ex. fr√©quence), il faut les recoder ici.
# Ce code suppose que 0 = non consomm√©, 1 = consomm√© (sinon adapter ce bloc).
# Base_MAD[, variables_hdds] <- lapply(Base_MAD[, variables_hdds], function(x) ifelse(x > 0, 1, 0))

# ‚úÖ √âtape 4 : Calcul du score HDDS par m√©nage
Base_MAD$HDDS_Score <- rowSums(Base_MAD[, variables_hdds], na.rm = TRUE)

# ‚úÖ √âtape 5 (optionnel) : Affichage d‚Äôun r√©sum√© statistique du score
summary(Base_MAD$HDDS_Score)

```

<br>

## II.6¬∞)	Score de r√©silience auto-√©valu√©e (SERS)

<br>

Le SERS est calcul√© √† partir de 10 sous-√©nonc√©s utilisant une √©chelle de Likert en cinq points (allant de ¬´ pas du tout d'accord ‚Äú √† ‚Äù tout √† fait d'accord ¬ª) pour saisir la perception qu'ont les m√©nages de leurs capacit√©s de r√©silience existantes ou de leur capital de moyens de subsistance. Le score de capacit√© de r√©silience regroupe les r√©ponses non pond√©r√©es aux 10 sous- √©nonc√©s et est normalis√© pour fournir un score allant de 0 √† 100.
Le score de r√©silience est normalis√© par la m√©thode minmax, transformant les r√©sultats en un score allant de 0 (pas du tout r√©silient) √† 100 (totalement r√©silient).


<br>

###  II.6.a¬∞)	Analyse descriptive des variables qui composent le SERS

<br>

Pour faire l'analyse descriptive sur le SERS on s'int√©r√©sse aux variables suivantes: SERSRevenue, SERSMoyen, SERSDifficultes, SERSSurvivre, SERSFamAmis, SERSPoliticiens, SERSLecons, SERSPreparerFuture, SERSAvertissementEven. 

```{r analyse descriptive sur SERS,error=TRUE,echo=FALSE, message=FALSE, warning=FALSE}
#  Charger les biblioth√®ques n√©cessaires
library(gtsummary)
library(dplyr)

# ‚úÖ √âtape 1 : D√©finir les variables du SERS
variables_sers <- c("SERSRevenue", "SERSMoyen", "SERSDifficultes", 
                    "SERSSurvivre", "SERSFamAmis", "SERSPoliticiens", 
                    "SERSLecons", "SERSPreparerFuture", "SERSAvertissementEven")

# ‚úÖ √âtape 2 : V√©rifier que toutes les variables existent dans la base
variables_sers <- variables_sers[variables_sers %in% names(Base_MAD)]

# ‚úÖ √âtape 3 : Cr√©er un tableau de statistiques descriptives pour le SERS
tableau_sers <- Base_MAD[, variables_sers] %>%
  tbl_summary(
    type = all_continuous() ~ "continuous",  # Type des variables
    statistic = list(
      all_continuous() ~ "{mean} (¬±{sd})\nMin: {min}, Max: {max}\nNA: {n_miss}"
    ),
    digits = all_continuous() ~ 1,  # Arrondir √† 1 d√©cimale
    missing = "always"  # Afficher toujours le nombre de valeurs manquantes
  ) %>%
  modify_caption("**üìä Tableau : Statistiques descriptives des variables composant le SERS**")

# ‚úÖ √âtape 4 : Affichage du tableau
tableau_sers

```

<br>

### **Analyse**: 

<br>

###  II.6.b¬∞)	Calculer le SERS.

<br>

```{r calcul SERS, echo=FALSE, warning=FALSE, message=FALSE}
# üì¶ Charger les biblioth√®ques n√©cessaires
library(dplyr)

# ‚úÖ √âtape 1 : D√©finir les variables du SERS
variables_sers <- c("SERSRevenue", "SERSMoyen", "SERSDifficultes", 
                    "SERSSurvivre", "SERSFamAmis", "SERSPoliticiens", 
                    "SERSLecons", "SERSPreparerFuture", "SERSAvertissementEven")

# ‚úÖ √âtape 2 : V√©rifier que toutes les variables existent dans la base
variables_sers <- variables_sers[variables_sers %in% names(Base_MAD)]

# ‚úÖ √âtape 3 : Calculer le score brut du SERS pour chaque m√©nage
# Somme des r√©ponses des 10 sous-√©nonc√©s
Base_MAD$SERS_Score_Brut <- rowSums(Base_MAD[, variables_sers], na.rm = TRUE)

# ‚úÖ √âtape 4 : Normaliser le score du SERS avec la m√©thode Min-Max
# Calcul des min et max du score brut
x_min <- min(Base_MAD$SERS_Score_Brut, na.rm = TRUE)
x_max <- max(Base_MAD$SERS_Score_Brut, na.rm = TRUE)

# Normalisation du score (0 √† 100)
Base_MAD$SERS_Score_Normalise <- (Base_MAD$SERS_Score_Brut - x_min) * 100 / (x_max - x_min)

# ‚úÖ √âtape 5 : Cat√©goriser le score SERS en terciles (faible, moyen, √©lev√©)
Base_MAD$SERS_Categorisation <- cut(Base_MAD$SERS_Score_Normalise,
                                     breaks = c(-Inf, 33, 66, Inf),
                                     labels = c("Faible", "Moyen", "Elev√©"),
                                     right = TRUE)

# ‚úÖ √âtape 6 : Afficher le r√©sum√© des r√©sultats
summary(Base_MAD$SERS_Score_Normalise)  # R√©sum√© du score normalis√©
table(Base_MAD$SERS_Categorisation)     # Comptage des cat√©gories

```

<br>

### **Analyse**: 

<br>

## II.7¬∞)	R√©gime alimentaire minimum acceptable (MAD)

<br>

Ici on s'int√©r√©sse aux variables: PCIYCInfFormNb ,PCIYCDairyMiNb , PCIYCDairyYoNb , PCIYCStapPoNb , MAD_module , PCMADStapCer , PCMADVegOrg , PCMADStapRoo , PCMADVegGre , PCMADFruitOrg , PCMADVegFruitOth , PCMADPrMeatO, PCMADPrMeatF, PCMADPrEgg, PCMADPrFish , PCMADPulse, PCMADDairy, PCMADFatRpalm, PCMADSnfChild, PCMADSnfPowd, PCMADSnfLns, PCIYCMeals


<br>

### II.7.a¬∞)	Cr√©er une variable qui renseigne le nombre de groupes d‚Äôaliments consomm√© par un enfant.

<br>

```{r, error=TRUE, message=FALSE, warning=FALSE, echo=FALSE}
# Liste des variables qui correspondent aux groupes alimentaires consomm√©s par l'enfant
variables_groupes_aliments <- c(
  "HDDSStapCer", "HDDSStapRoot", "HDDSPulse", 
  "HDDSVegOrg", "HDDSVegGre", "HDDSVegOth", 
  "HDDSFruitOrg", "HDDSFruitOth", "HDDSPrMeatF", 
  "HDDSPrMeatO", "HDDSPrFish", "HDDSPrEgg", 
  "HDDSDairy", "HDDSSugar", "HDDSFat"
)

# Cr√©er la variable "NbGroupesAlimentaires" qui compte le nombre de groupes d'aliments consomm√©s
Base_MAD$NbGroupesAlimentaires <- apply(Base_MAD[, variables_groupes_aliments], 1, function(x) {
  # Compter combien de groupes ont une valeur diff√©rente de 0 (c'est-√†-dire consomm√©s)
  sum(x > 0, na.rm = TRUE)
})

# Afficher les 6 premi√®res lignes pour v√©rifier la nouvelle variable
head(Base_MAD$NbGroupesAlimentaires)

```

<br>

### II.7.b¬∞)	Cr√©er une variable DDM qui indique si l'enfant a consomm√© au moins cinq groupes d'aliments

<br>

```{r cr√©ation de la variable DDM,error=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
# Cr√©er la variable "DDM" qui indique si l'enfant a consomm√© au moins cinq groupes d'aliments
Base_MAD$DDM <- ifelse(Base_MAD$NbGroupesAlimentaires >= 5, 1, 0)

# Afficher les 6 premi√®res lignes pour v√©rifier la nouvelle variable
head(Base_MAD$DDM)

```

<br>

La variable cr√©√©e prends la valeur 1 si la condition est v√©rifi√©e et 0 sinon. 

<br>

II.7.c¬∞)	Quelle est la proportion d'enfants √¢g√©s de 6 √† 23 mois b√©n√©ficiant d'un r√©gime alimentaire minimum acceptable

<br>

```{r analyse sur les enfants de 6 √† 23 mois, error=TRUE,message=FALSE, warning=FALSE, message=FALSE}
## Filtrer les m√©nages avec au moins un enfant de 6 √† 23 mois
base_enfants_623m <- Base_MAD[Base_MAD$HHSize23M > 0, ]

# Calculer la proportion de m√©nages avec DDM
proportion_DDM <- mean(base_enfants_623m$DDM == 1, na.rm = TRUE) * 100

# Afficher la proportion
cat("üîπ Proportion de m√©nages avec au moins un enfant de 6-23 mois ayant un DDM :", round(proportion_DDM, 1), "%\n")

```

<br>

### II.7.d¬∞)	Faites les statistiques descriptives de cette variable suivant le sexe du chef de menage

<br>

```{r stat_desc sexe VS DDM,error=TRUE, message=FALSE, echo=FALSE, warning=FALSE}
# üìå Charger les packages n√©cessaires
library(gtsummary)

# üìå Cr√©er une sous-base contenant uniquement les variables utiles
base_ddm <- Base_MAD[, c("DDM", "HHHSex")]

# üìå Transformer la variable HHHSex en facteur pour qu'elle soit bien trait√©e comme cat√©gorielle
base_ddm$HHHSex <- as.factor(as.character(base_ddm$HHHSex))

# üìå Cr√©er un tableau r√©capitulatif du DDM selon le sexe du chef de m√©nage
tableau_ddm <- tbl_summary(
  data = base_ddm,
  by = HHHSex,                            # Comparaison par sexe du chef de m√©nage
  statistic = DDM ~ "{n} ({p}%)",         # Affiche nombre et pourcentage
  label = list(DDM ~ "DDM (min. 5 groupes)"),
  missing = "no"                          # Ne pas inclure les NA
)

# üìå Ajouter un titre au tableau
tableau_ddm <- modify_caption(tableau_ddm, "**Tableau : DDM selon le sexe du chef de m√©nage**")

# üìå Afficher le tableau
tableau_ddm

```



<br>

**Analyse**: On constate que pour les m√©nages dont le chef est un homme **61%** des enfants entre 6 et 23 mois ont ey un DDM = 1 et que pour les m√©nages dont le chef est une femme ce pourcentage est de **56%**. 

<br>

```{r, error=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Liste des variables attendues
variables_hdds <- c(
  "HDDSStapCer", "HDDSPulse", "HDDSDairy", "HDDSPrMeat", "HDDSPrFish",
  "HDDSPrEgg", "HDDSFat", "HDDSSugar", "HDDSCond"
)

# V√©rifier si elles sont toutes pr√©sentes dans Base_MAD
variables_presentes <- variables_hdds %in% names(Base_MAD)

# Afficher les r√©sultats
data.frame(
  Variable = variables_hdds,
  Presente_dans_Base_MAD = variables_presentes
)

```

