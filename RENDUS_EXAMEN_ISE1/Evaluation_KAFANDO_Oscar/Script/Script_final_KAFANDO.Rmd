---
output:
  html_document:
    toc: true
    toc_depth: 2
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      cache = TRUE,
                      warning = FALSE, 
                      message = FALSE,
                      comment = NA)

```

<!--Installation et importation des packages**-->

```{r}

#Installation et importation des packages

packages <- c("modeest","sf","tmap","flextable","data.table","survey","officer","officedown","haven","utils","dplyr","gtsummary","gt","labelled","janitor","tidyverse","naniar","DataExplorer","summarytools","stringi","stringr","ggrepel")


for (package in packages) {
  if (!requireNamespace(package, quietly = TRUE)) {   # V√©rifie si le package n'est pas encore install√©
    install.packages(package)
  }
  library(package, character.only = TRUE) # nom du package en nom ou chaine de caract√®re ()
}


```

```{r page_garde_1}

flextable(data.frame(Contenu = "REPUBLIQUE DU SENEGAL")) %>% #Cr√©er un tableau flextable
  delete_part(part = "header") %>% #supprimer l'en-t√™te
  border_remove() %>% #Supprimer les bordures
  
  # Application de la police
  font(fontname = "Times New Roman", part = "all") %>% 
  fontsize(size = 14, part = "all") %>% 
  
  # Mise en forme du texte
  bold(i = 1, j = 1) %>% 
  align(align = "center") %>% 
  
  set_table_properties(layout = "autofit", width = 1) #Ajuste la largeur des colonnes automatiquements

```

|                                                            |
|:----------------------------------------------------------:|
| ![](../Documents/Logo%20SEN.png){width="3cm" height="3cm"} |

```{r page_garde_2}

flextable(data.frame(Contenu = c( "**********",
                                  "Un Peuple - Un But - Une Foi",
                                  "**********",
                                  "Agence nationale de la Statistique et de la d√©mographie"))) %>% 
  delete_part(part = "header") %>% 
  border_remove() %>% 
  
  # Application de la police
  font(fontname = "Times New Roman", part = "all") %>% 
  fontsize(size = 14, part = "all") %>%
  
  # Mise en forme du texte
  bold(i = 1:4, j = 1) %>% 
  italic(i = 2, j = 1) %>% 
  align(align = "center") %>% 
  
  set_table_properties(layout = "autofit", width = 1)

```

|                                                |
|:----------------------------------------------:|
| ![](../Documents/Logo-ANSD.png){width="3.5cm"} |

```{r page_garde_3}

flextable(data.frame(Contenu = c("**********",
                                  "Ecole nationale de la Statistique et de l'Analyse √©conomique Pierre Ndiaye"))) %>%
  delete_part(part = "header") %>% 
  border_remove() %>% 
  
  # Application de la police
  font(fontname = "Times New Roman", part = "all") %>% 
  fontsize(size = 14, part = "all") %>% 
  
  # Mise en forme du texte
  bold(i = 1:2, j = 1) %>% 
  align(align = "center") %>% 
  
  set_table_properties(layout = "autofit", width = 1)

```

|                                                                    |
|:------------------------------------------------------------------:|
| ![](../Documents/ENSAE-Dakar-logo.png){width="2.5cm" height="2cm"} |

##### Projet statistique sur R : Evaluation

```{r page garde_4, include=FALSE}

flextable(data.frame(Contenu = "Projet statistique avec R")) %>%
  delete_part(part = "header") %>% 
  border_remove() %>% 
  
  # Application de la police
  font(fontname = "Times New Roman", part = "all") %>% 
  fontsize(size = 15, part = "all") %>% 
  
  # Mise en forme du texte
  italic(i = 1, j = 1) %>% 
  align(align = "center") %>% 
  
  set_table_properties(layout = "autofit", width = 1)

```



```{r page_garde_5}
donnees <- data.frame(
  col1 = c("R√©dig√© par", "KAFANDO G. Judica√´l Oscar", "√âl√®ve Ing√©nieur Statisticien √âconomiste"),
  col2 = c("Sous la supervision de", "M. Aboubacar HEMA", "Data-scientist"),
  stringsAsFactors = FALSE
)
flextable(donnees) %>% 
  delete_part(part = "header") %>% 
  width(j = 1:2, width = 0.5) %>%  # R√©partition √©gale de la largeur
  align(j = 1, align = "left") %>% 
  align(j = 2, align = "right") %>% 
  border_remove() %>% 
  bold(i = 1, j = 1:2) %>% 
  italic(i = 3, j = 1:2) %>% 
  set_table_properties(layout = "autofit", width = 1) %>%  # Force la largeur totale
  fontsize(size = 11)  # Ajuste la taille de police si n√©cessaire
```

|                                |
|:------------------------------:|
| **Ann√©e acad√©mique 2024-2025** |

<!--Cr√©ation des fonctions qui sernt utilis√© par suite-->

```{r description_fonction}
# D√©finition d'une fonction qui prend en entr√©e un dataframe √† d√©crire et un nom optionnel pour identifier la base dans le texte g√©n√©r√©

description_base <- function(df, nom_base = "la base") {
  
  # R√©cup√®rer le nombre d'observations (lignes) dans le dataframe
  n_obs <- nrow(df)
  
  # R√©cup√®re le nombre de variables (colonnes) dans le dataframe
  n_var <- ncol(df)
  
  # Identifie le type de chaque variable puis compter le nombre de fois qu'il apparait
  type_counts <- sapply(df, function(x) class(x)[1]) |> table()
  
  # Cr√©e une cha√Æne de texte d√©crivant combien de variables de chaque type sont pr√©sentes
  type_text <- paste0(type_counts, " variable(s) du type ",
                      names(type_counts),
                      collapse = ", "  # S√©pare chaque groupe par une virgule
  )
  
  # Afficher le r√©sum√© format√©
  cat(sprintf(
    "\n%s contient %d variables sur %d individus.\nParmi les variables, on trouve : %s.\n\n",
    nom_base, n_var, n_obs, type_text
  ))
}


```

```{r design_tableau_couleur1}

style_flextable <- function(tableau,
                            caption = "Tableau personnalis√©",
                            conditional_cols = NULL,
                            seuil1 = NULL,
                            seuil2 = NULL,
                            colors = c("#FFFFFF", "#C6E0B4", "#A9D08E")) {
  
  ft <- flextable(tableau) %>%
    theme_booktabs() %>%
    bg(bg = "#4472C4", part = "header") %>%
    color(color = "white", part = "header") %>%
    bold(part = "header") %>%
    bold(j = 1) %>%
    bold(part = "footer") %>%
    bg(bg = "#D9E1F2", part = "footer") %>%
    hline_top(border = fp_border(color = "#4472C4", width = 2), part = "header") %>%
    hline_bottom(border = fp_border(color = "#4472C4", width = 1), part = "header") %>%
    hline_bottom(border = fp_border(color = "#4472C4", width = 2), part = "body") %>%
    align(align = "center", part = "all") %>%
    valign(valign = "center", part = "all") %>%
    padding(padding = 4, part = "all") %>%
    fontsize(size = 10, part = "all") %>%
    set_caption(caption) %>%
    autofit()
  
  # Application du formatage conditionnel si toutes les conditions sont remplies
  if (!is.null(conditional_cols) && !is.null(seuil1) && !is.null(seuil2) && length(colors) == 3) {
    for (col in conditional_cols) {
      ft <- ft %>%
        bg(j = col, bg = function(x) {
          val <- as.numeric(x)
          ifelse(val <= seuil1, colors[1],
                 ifelse(val <= seuil2, colors[2], colors[3]))
        })
    }
  }
  
  return(ft)
}

```

\newpage

###### Sommaire

<!---BLOCK_TOC--->

\newpage

###### Liste des figures

<!---BLOCK_TOC{seq_id: 'fig'}--->

\newpage

###### Liste des tableaux

<!---BLOCK_TOC{seq_id: 'tab'}--->

\newpage

###### Introduction

Dans le cadre du cours de Projet statistique sous R, cette √©tude applique les comp√©tences acquises en traitement, analyse et visualisation de donn√©es pour explorer la situation alimentaire et nutritionnelle des populations r√©fugi√©es et des communaut√©s h√¥tes. √Ä travers l'exploitation d'une base de donn√©es issue d'une enqu√™te terrain, ce travail vise √† d√©crire les caract√©ristiques socio-d√©mographiques des m√©nages, analyser la diversit√© alimentaire et identifier les vuln√©rabilit√©s sp√©cifiques selon les groupes. L‚Äôensemble des analyses, r√©alis√©es sous R, permet d‚Äôillustrer concr√®tement l‚Äôusage d‚Äôoutils statistiques dans un contexte humanitaire, et de fournir des r√©sultats appuy√©s sur des m√©thodes rigoureuses et reproductibles.

<br>

\newpage

# Analayse et compr√©hension de la base

<!--Importation des bases-->

```{r import_base}
##
base_individu <-  haven::read_dta("../Data/Base_Individus.dta") %>%  # Importation de la base ind
  janitor::clean_names() #Nettoyage des noms de variables

base_principale <-  haven::read_dta("../Data/Base_Principale.dta") %>% 
  janitor::clean_names() #Nettoyage des noms de variables



```

## **Structure de la base**

Le but est d'avoir une vue globale de la base.

```{r}
#glimpse(base_menage) # Structure de la base m√©nage

description_base(base_individu, nom_base = "La base individu")

description_base(base_principale,"La base principale")

```

## V√©rification et suppression des colonnes ou lignes vides

Les **colonnes et lignes vides** n'ont aucune information pour nous. Donne nous les supprimons pour alleger la base et le traitement.

```{r}

col_total_ind <- ncol(base_individu) #nombre total de colonne avant suppression
ligne_total_ind <-nrow(base_individu) #nombre total de ligne avant suppression

col_total_prin <- ncol(base_principale) #nombre total de colonne avant suppression
ligne_total_prin <-nrow(base_principale) #nombre total de ligne avant suppression

```

```{r}

# Trouver les colonnes vides (toutes les valeurs sont NA)


base_individu <- base_individu %>%
  janitor::remove_empty(which = "cols") %>%  #v√©rifier par colonnes et garder uniquement les colonnes non vides
janitor::remove_empty(which = "rows") #v√©rifier par lignes et garder uniquement les lignes  non vides


base_principale <- base_principale %>%
  janitor::remove_empty(which = "cols") %>%  #v√©rifier par colonnes et garder uniquement les colonnes non vides
janitor::remove_empty(which = "rows") #v√©rifier par lignes et garder uniquement les lignes  non vides

```

```{r}

col_vide_ind <- col_total_ind - ncol(base_individu)  #nombre total de colonne vide
ligne_vide_ind <- ligne_total_ind -  nrow(base_individu) #nombre total de ligne vide

ligne_vide_prin <-ligne_total_prin-nrow(base_principale) #nombre total de colonne vide
col_vide_prin <- col_total_prin - ncol(base_principale) #nombre total de ligne vide

```

Les bases **principale et individus** contiennent respectivement `r col_vide_prin` et `r col_vide_ind` colonnes vides et `r ligne_vide_prin` et `r ligne_vide_ind`lignes vides.

## V√©rifications des doublons

Les doublons dans une base, compte pour des informations r√©p√©t√©es et qui biaisent les r√©sultats. Nous examinons donc les deux bases et en cas d'existence, nous les supprimons pour ne garder qu'un seul.

```{r doublon}

doublon_ind <- base_individu %>% janitor::get_dupes()
base_individu <- base_individu %>% 
  distinct()

doublon_prin <- base_principale %>% janitor::get_dupes()
base_principale <- base_principale %>% 
  distinct()

#nrow(doublon_prin)
#nrow(doublon_ind)

```

La base principale a `r nrow(doublon_prin)` doublons et la base individu en a `r nrow(doublon_ind)`.

## V√©rification des identifiants (coh√©rence relationnelle)

```{r}
# V√©rifier unicit√© des ID m√©nages
any(duplicated(base_principale$id))  # Doit √™tre FALSE

# V√©rifier que tous les individus ont un m√©nage valide
all(base_individu$id %in% base_principale$id)  # Doit √™tre TRUE

# V√©rifier unicit√© par combinaison
library(dplyr)
base_individu %>%
  group_by(id, rosterposition) %>%
  summarise(n = n()) %>%
  filter(n > 1) 

```

Les v√©rifications effectu√©es sur les identifiants ont permis de confirmer l‚Äôint√©grit√© relationnelle entre les deux bases de donn√©es. Aucun doublon n‚Äôa √©t√© d√©tect√© au niveau des identifiants des m√©nages, ce qui garantit leur unicit√©. De plus, l‚Äôensemble des individus recens√©s dans la base individuelle sont correctement rattach√©s √† un m√©nage valide dans la base principale. Enfin, la combinaison de l‚Äôidentifiant du m√©nage et de la position dans le m√©nage **(rosterposition)** est unique, ce qui atteste de l‚Äôabsence de doublons au sein des m√©nages. Ces r√©sultats valident la structure hi√©rarchique des donn√©es et confirment la fiabilit√© des liens entre les deux niveaux d‚Äôobservation.

## V√©rification de la coh√©rence inter-variable

L'**objectif** est de s‚Äôassurer que les r√©ponses d‚Äôune variable sont coh√©rentes avec d'autres r√©ponses du m√™me individu ou m√©nage. Par exemple :

-   *Une personne qui dit ne pas avoir fui ne peut pas d√©clarer une cause de fuite*
-   *Une personne ayant d√©clar√© √™tre n√©e dans le pays d‚Äôaccueil ne devrait pas avoir une date d'arriv√©e*
-   *Une femme de 5 ans ayant eu un enfant : incoh√©rent*

```{r results='hide'}

# Fuite sans raison de fuite
base_individu %>%
  labelled::to_factor() %>% #labelliser les variables
  filter(id_01a == "Non" & !is.na(id_02))

# Naissance dans le pays vs date d'arriv√©e
base_individu %>%
  labelled::to_factor() %>% #labelliser les variables
  filter(hh_00 == "Oui" & (!is.na(hh_00a_year) | !is.na(hh_00a_month)))

# Enfant tr√®s jeune ayant donn√© naissance
base_individu %>%
  labelled::to_factor() %>% #labelliser les variables
  filter(age_years < 10 & hh_27 == "Oui") #filtrer ceux dont l'age est inf√©rieur √† 10 et ont donn√© naissance


```

Les r√©sultats des trois contr√¥les cibl√©s montre que chez les personnes ayant d√©clar√© ne pas avoir fui leur domicile et ceux n‚Äôavaient pas indiqu√© de raison de fuite ; aucune contradiction n‚Äôa √©t√© observ√©e. Pour les individus ayant d√©clar√© avoir toujours v√©cu dans le pays d‚Äôaccueil tout en renseignant une date d‚Äôarriv√©e, aucun cas de ce type n‚Äôa √©t√© trouv√©. Enfin, la pr√©sence d‚Äôenfants de moins de 10 ans ayant d√©clar√© avoir donn√© naissance √† un enfant, aucune anomalie n‚Äôa √©t√© d√©tect√©e.

## V√©rification des valeurs manquantes et aberrantes

Objectif : s'assurer que les variables importantes sont renseign√©es et qu'il n'y a pas d'aberrations statistiques ou logiques.

```{r results='hide'}

# V√©rifier √¢ges
base_individu %>% filter(age_years < 0 | age_years > 120)

# Sexe incoh√©rent
table(base_individu$hh_02, useNA = "always")  # Doit contenir uniquement 1, 2

# Parent√© incoh√©rente
table(base_individu$hh_03)

```

La v√©rification des √¢ges a permis de s‚Äôassurer qu‚Äôaucune valeur aberrante ne figure dans la variable age_years. Aucun individu n‚Äôa √©t√© enregistr√© avec un √¢ge n√©gatif ou sup√©rieur √† 120 ans. Aussi, aucune incoh√©rence n‚Äôest observ√©e,au niveau de la variable sexe. Enfin, l‚Äôanalyse de la distribution des r√©ponses permet de confirmer la diversit√© attendue des positions dans le m√©nage (chef, conjoint(e), enfant, etc.). Aucun code inattendu n‚Äôa √©t√© d√©tect√©, et le nombre de chef de m√©nage est √©gale √† la taille de la base m√©nage.

# Caract√©ristiques socio-d√©mographiques

## Pyramide des ages des indivdus

### Pr√©paration des donn√©es

Dans cette partie, nous pr√©parons les donn√©es pour une meilleur repr√©sentation

```{r}

# Cr√©er des groupes d'√¢ge (tranches de 5 ans)
base_individu <- base_individu %>%
  mutate(age_group = cut(
  as.numeric(age_years),
    breaks = seq(0, 100, by = 5),   # Tranches 0‚Äì4, 5‚Äì9, ..., 95‚Äì99
    right = FALSE,
    include.lowest = TRUE
  ))



# R√©sumer les effectifs par groupe d'√¢ge et sexe
pyramide <- base_individu %>%
  labelled::to_factor() %>% 
  filter(!is.na(hh_02), !is.na(age_group)) %>%
  group_by(age_group, hh_02) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(n = ifelse(hh_02 == "Female", n, -n))  # Femme √† droite, Homme √† gauche


```

### Representation de la pyramide

```{r, fig.cap="Pyramide des √¢ges par sexe"}


# Affichage avec ligne centrale et 85+
ggplot(pyramide, aes(x = age_group, y = n, fill = hh_02)) +
  geom_bar(stat = "identity", width = 0.9) +
  coord_flip() +
  geom_vline(xintercept = 0, color = "black", linetype = "solid") +  # Ligne au centre
  scale_y_continuous(
    labels = abs,
    expand = expansion(mult = c(0.05, 0.05))
  ) +
  scale_fill_manual(values = c("Male" = "#ADD8E6", "Female" = "#00008B")) +
  labs(
    title = "Pyramide des √¢ges",
    x = "Tranches d'√¢ge",
    y = "Effectif",
    fill = "Sexe"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

La pyramide des √¢ges issue de l‚Äôenqu√™te sur les d√©placements forc√©s au Sud-Soudan en 2023 met en √©vidence une structure d√©mographique fortement juv√©nile, caract√©ris√©e par une concentration marqu√©e dans les tranches d‚Äô√¢ge de 0 √† 20 ans. Cette surrepr√©sentation des enfants et adolescents refl√®te les dynamiques de natalit√© √©lev√©es typiques des contextes de crise humanitaire. La distribution par sexe reste relativement √©quilibr√©e dans les tranches jeunes, mais l‚Äôon observe une pr√©dominance f√©minine progressive chez les adultes, probablement li√©e √† des sch√©mas de mobilit√©, de mortalit√© diff√©rentielle ou de composition des foyers d√©plac√©s. La faible pr√©sence des personnes √¢g√©es et quelques pics irr√©guliers dans les classes sup√©rieures sugg√®rent √† la fois une esp√©rance de vie limit√©e et des impr√©cisions dans la d√©claration de l‚Äô√¢ge.

### Caract√©ristique du chef de m√©nage

```{r}
tab_carac <- base_individu %>%
  filter(hh_03 == 1) %>%  # garder seulement 2 modalit√©s
  to_factor() %>%
  mutate(age_years = as.numeric(age_years) ) %>%  # conversion explicite en numeric
  select(age_years, hh_02, hh_08, intro_07_1) %>%
  droplevels() %>%  # Supprime les modalit√©s vides dans 'intro_07_1'
  tbl_summary(
    by = intro_07_1,
    
    statistic = list(
      age_years ~ "{mean} ({min},{max}))",       # Affiche uniquement la moyenne et l'√©cart-type
      all_categorical() ~ "{p}%"         # Pourcentage pour les autres
    ),
    digits = all_continuous() ~ 1,
    missing = "no"
  ) %>%
  add_p(
    test = list(
      age_years ~ "t.test",              # Test t pour l'√¢ge
      hh_02 ~ "chisq.test",  # Test du chi¬≤ pour les autres
      hh_08 ~ "fisher.test"  # test de Fisher ici
    )
  ) %>%
  modify_header(
    label~"Caract√©ristiques du chef de menage") %>% 
  bold_labels()

```

```{r}

# Convertir en flextable 
tab_carac_flex <- as_flex_table(tab_carac) %>%
  set_caption(
    caption = "Caract√©ristiques des individus selon le groupe",
    autonum = officer::run_autonum(seq_id = "tab", pre_label = "Tableau ", bkm = "tab_carac")
  )

tab_carac_flex

```

Les chefs de m√©nage r√©fugi√©s et ceux de la communaut√© h√¥te du Nord ont un √¢ge m√©dian similaire (environ 41,6 ans). Cependant, on observe des diff√©rences significatives selon le sexe : les femmes repr√©sentent 46 % chez les r√©fugi√©s contre 37 % dans la communaut√© h√¥te (p < 0,001). Concernant le statut matrimonial, les r√©fugi√©s sont moins souvent mari√©s de fa√ßon monogame (63 % vs 72 %) ou polygame (14 % vs 19 %). En revanche, ils sont plus souvent s√©par√©s, divorc√©s, veufs ou jamais mari√©s que les membres de la communaut√© h√¥te. Ces diff√©rences sont statistiquement significatives.


##Crowding Index ou l‚Äôindice d‚Äôaffluence

L'indice d'affluence est le nombre de membres du menage divise par le nombre de pi√®ces (√† l'exclusion de la cuisine et des couloirs).

### Calculez le nombre d‚Äôindividu par menage

Pour cette partie, nous utilisons la base individu et nous sommons simplement les indivdus du meme m√©nage pour avoir la taille du m√©nage. Une fois cela fait, nous ajoutons cette variable √† la base principale.

```{r results='hide'}

taille_menage <- base_individu %>%
  group_by(id) %>%
  summarise(taille_menage = n())

# Ajout √† la base principale

base_principale <- left_join(base_principale,taille_menage,by="id")

```

### Faites les statistiques descriptives sur cette variable

```{r}

# Cr√©er un tableau
stat_taille_menage <- base_principale %>%
  summarise(
    `Moyenne` = round(mean(taille_menage, na.rm = TRUE),1),
    `M√©diane` = round(median(taille_menage, na.rm = TRUE),1),
    `Mode` = round(mfv(taille_menage, na_rm = TRUE)[1],1),
    `√âcart-type` = round(sd(taille_menage, na.rm = TRUE),1),
    `Minimum` = round(min(taille_menage, na.rm = TRUE),1),
    `Maximum` = round(max(taille_menage, na.rm = TRUE),1)
  ) %>%
  tidyr::pivot_longer(everything(), names_to = "Statistique", values_to = "Valeur")

# Cr√©er une flextable avec un titre pour Word
flextable(stat_taille_menage) %>%
  set_caption("Statistiques descriptives de la taille du m√©nage") %>%
  autofit()


```

La taille moyenne des m√©nages est de 7,2 personnes, avec une m√©diane et un mode de 7, ce qui indique une distribution centr√©e autour de cette valeur. La taille des m√©nages varie de 1 √† 17 personnes, avec un √©cart-type de 3,2, montrant une certaine variabilit√© entre les m√©nages.


### Faites des statistiques descriptives sur la variable renseigant le nombre de pieces du menage

```{r}


# Cr√©er un tableau
stat_taille_menage <- base_principale %>%
  labelled::to_factor() %>% 
  summarise(
    `Moyenne` = round(mean(hh14, na.rm = TRUE),1),
    `M√©diane` = round(median(hh14, na.rm = TRUE),1),
    `Mode` = round(mfv(hh14, na_rm = TRUE)[1],1),
    `√âcart-type` = round(sd(hh14, na.rm = TRUE),1),
    `Minimum` = round(min(hh14, na.rm = TRUE),1),
    `Maximum` = round(max(hh14, na.rm = TRUE),1)
  ) %>%
  tidyr::pivot_longer(everything(), names_to = "Statistique", values_to = "Valeur")

# Cr√©er une flextable avec un titre pour Word
flextable(stat_taille_menage) %>%
  set_caption("Statistiques descriptives du nombre de pi√®ce") %>%
  autofit()


```

En moyenne, les m√©nages disposent de 2,4 pi√®ces, avec une m√©diane et un mode de 2, ce qui sugg√®re que la plupart des logements ont deux pi√®ces. Le nombre de pi√®ces varie de 1 √† 21, avec un √©cart-type de 1,3, indiquant une dispersion mod√©r√©e autour de la moyenne.


### Calculez l‚Äôindice d‚Äôaffluence ou crowding index

```{r}
# Pr√©parer la base avec les variables pertinentes
base_ind_affluence <- base_principale %>%
  select(id, hh14, intro_07_1, taille_menage) %>%
  filter(!is.na(hh14), !is.na(taille_menage), hh14 != 0)  # √âviter division par z√©ro ou valeurs manquantes

#Calculer l'indice d'affluence (crowding index)
base_ind_affluence <- base_ind_affluence %>%
  mutate(crowding_index = taille_menage / hh14)

```

```{r}
#Visualiser la distribution avec un histogramme
ggplot(base_ind_affluence, aes(x = crowding_index)) +
  geom_histogram(binwidth = 0.5, fill = "#9ACD32", color = "black", boundary = 0) +
  labs(
    title = "Distribution de l'indice d'affluence (Crowding Index)",
    x = "Indice d'affluence (nombre de personnes par pi√®ce)",
    y = "Nombre de m√©nages"
  ) +
  theme_minimal(base_size = 13) +
  xlim(0, 10) +
  geom_vline(aes(xintercept = mean(crowding_index, na.rm = TRUE)),
             color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = mean(base_ind_affluence$crowding_index, na.rm = TRUE), y = Inf,
           label = "Moyenne", vjust = 2, color = "red", size = 4)


```

### Quelle est la proportion de menage dont le crowding index est: \<1, 1\<= crowding_index\<2, 2\<= crowding_index\<3 et \>=3

```{r, echo=FALSE,crowding_table}


# Cat√©goriser l'indice d'affluence selon les seuils demand√©s
base_ind_affluence <- base_ind_affluence %>%
  mutate(categorie_crowding = case_when(
    crowding_index < 1 ~ "< 1",
    crowding_index >= 1 & crowding_index < 2 ~ "1 - 2",
    crowding_index >= 2 & crowding_index < 3 ~ "2 - 3",
    crowding_index >= 3 ~ ">= 3",
    TRUE ~ NA_character_
  ))

# Calcul des proportions par cat√©gorie
proportions_crowding <- base_ind_affluence %>%
  group_by(categorie_crowding) %>%
  summarise(n = n()) %>%
  mutate(proportion = n / sum(n) * 100)

# Supprimer les lignes contenant NA dans la variable cat√©gorielle
proportions_crowding_clean <- proportions_crowding %>%
  filter(!is.na(categorie_crowding))

#Cr√©er une flextable propre et stylis√©e
ft_crowding <- flextable(proportions_crowding_clean) %>%
  set_header_labels(
    categorie_crowding = "Cat√©gorie d'affluence",  # Renommer colonnes
    n = "Effectif",
    proportion = "Proportion (%)"
  ) %>%
  colformat_num(j = "proportion", digits = 1) %>%  # Arrondir √† 1 d√©cimale
  autofit() %>%
  align(align = "center", part = "all") %>%        # Centrer le texte
  bold(part = "header") %>%                        # Mettre en gras les en-t√™tes
  theme_booktabs() %>%                             # Style propre type tableau acad√©mique
  set_caption("Distribution des cat√©gories d'affluence",
              autonum = run_autonum(seq_id = "tab", pre_label = "Tableau", bkm = "tab_crowding"))

#Afficher la table 
#ft_crowding

```

```{r}
# Visualisation par cat√©gorie
ggplot(proportions_crowding, aes(x = categorie_crowding, y = proportion, fill = categorie_crowding)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.1f%%", proportion)), vjust = -0.5) +
  labs(title = "Proportion des m√©nages par cat√©gorie d'indice d'affluence",
       x = "Indice d'affluence", y = "Proportion (%)") +
  theme_minimal() +
  theme(legend.position = "none")
```

La majorit√© des m√©nages (58,9 %) appartiennent √† la cat√©gorie d‚Äôaffluence √©lev√©e (‚â• 3), suivie de 23,8 % dans la cat√©gorie 2‚Äì3 et de 15,3 % dans la cat√©gorie 1‚Äì2. Seuls 2 % des m√©nages ont une affluence inf√©rieure √† 1, indiquant que tr√®s peu de m√©nages sont faiblement peupl√©s.

### Comparaison entre r√©fugi√©s et communaut√©s d'accueil

```{r}
# Analyse comparative entre r√©fugi√©s et communaut√©s d'accueil
comp_par_groupe <- base_ind_affluence %>%
  group_by(intro_07_1,categorie_crowding) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(intro_07_1) %>%
  mutate(proportion = n / sum(n) * 100)

# Statistiques descriptives par groupe de population
base_ind_affluence %>%
  to_factor() %>% 
  group_by(intro_07_1) %>%
  summarise(
    n = n(),
  moyenne = mean(crowding_index, na.rm = TRUE),
    mediane = median(crowding_index, na.rm = TRUE),
    ecart_type = sd(crowding_index, na.rm = TRUE),
    min = min(crowding_index, na.rm = TRUE),
    max = max(crowding_index, na.rm = TRUE)
  )

```

#### Boite √† moustache

```{r}


# Bo√Æte √† moustaches pour comparer les distributions
base_ind_affluence %>% 
  to_factor() %>% 
ggplot(aes(x = factor(intro_07_1), y = crowding_index, fill = factor(intro_07_1))) +
  geom_boxplot() +
  labs(title = "Distribution de l'indice d'affluence par groupe de population",
       x = "Groupe de population", y = "Indice d'affluence") +
  theme_minimal() +
  ylim(0, 10)  # Limiter l'axe des y pour une meilleure visualisation

```

# Analyse de la securite alimentaire des deplaces internes

## Score de consommation alimentaire (SCA): 10 points

### Analyse descriptives des variables qui compose le SCA

```{r }

# Liste des variables composants le SCA
sca_vars <- c("food_div1","food_div2","food_div3","food_div4","food_div5","food_div6","food_div7","food_div8")


# Nettoyage des valeurs (0‚Äì7)
base_principale <- base_principale %>%
  mutate(across(
    all_of(sca_vars),
    ~ as.numeric(.) %>% pmax(0) %>% pmin(7)
  ))

# Format long
sca_long <- base_principale %>%
  select(all_of(sca_vars)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "jours")

# Effectifs + pourcentages
sca_summary <- sca_long %>%
  group_by(variable, jours) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(variable) %>%
  mutate(pct = round(n / sum(n) * 100, 1)) %>%
  ungroup()

# Mise en forme pour tableau
sca_table <- sca_summary %>%
  mutate(jours = as.character(jours),
         stat = paste0(n, " (", pct, "%)")) %>%
  select(variable, jours, stat) %>%
  pivot_wider(names_from = variable, values_from = stat)


style_flextable(sca_table)%>%
  autofit() %>% 
  set_caption(
    caption = "Effectifs et pourcentages des groupes alimentaires selon le nombre de jours (0‚Äì7)",
    autonum = run_autonum(seq_id = "tab", bkm = "tab_manquant") # Pour la num√©rotation automatique et le signet
  )


```

Les r√©sultats montrent que la consommation alimentaire varie largement selon les groupes. Les c√©r√©ales et tubercules (food_div1) sont les plus fr√©quemment consomm√©s, avec 22,1 % des m√©nages n‚Äôen consommant pas du tout, et 22,6 % les consommant quotidiennement. En revanche, les l√©gumineuses/noix (food_div2), les l√©gumes (food_div5) et les fruits (food_div6) sont moins pr√©sents, avec des proportions √©lev√©es de m√©nages ne les consommant pas du tout (respectivement 62,1 %, 81,1 %, et 90,7 %). La consommation de viande/poisson/≈ìufs (food_div4) et de produits laitiers (food_div3) reste √©galement faible, bien que plus fr√©quente que celle des l√©gumes et fruits. Enfin, les mati√®res grasses (food_div7) et le sucre (food_div8) sont peu consomm√©s au quotidien, avec de faibles proportions de m√©nages les int√©grant r√©guli√®rement dans leur alimentation.

### Calculer le score de consommation alimentaire

üéØ Objectif Le SCA est obtenu en multipliant la fr√©quence de consommation de chaque groupe alimentaire par un poids nutritionnel, puis en faisant la somme pond√©r√©e

```{r}

# D√©finir les poids

sca_poids <- c(
  food_div1  = 2,  # C√©r√©ales & tubercules
  food_div2  = 3,  # L√©gumineuses/noix
  food_div5  = 1,  # L√©gumes
  food_div6  = 1,  # Fruits
  food_div4  = 4,  # Viande/poisson/≈ìufs
  food_div3  = 4,  # Produits laitiers
  food_div8  = 0.5,  # Sucre
  food_div7  = 0.5   # Mati√®res grasses
)

# Calculer le score pond√©r√©
base_principale <- base_principale %>%
  mutate(SCA = rowSums(across(all_of(names(sca_poids)), ~ . * sca_poids[cur_column()])))


```

### Faites un tableau illustrant le poids attribue a chaque groupe alimentaire pour le calcul du SCA (la somme totale des poids doit etre egale a 16)

```{r}

# Dictionnaire des libell√©s
libelles <- c(
  food_div1 = "C√©r√©ales & tubercules (jours)",
  food_div2 = "L√©gumineuses/noix (jours)",
  food_div5 = "L√©gumes (jours)",
  food_div6 = "Fruits (jours)",
  food_div4 = "Viande/poisson/≈ìufs (jours)",
  food_div3 = "Produits laitiers (jours)",
  food_div8 = "Sucre (jours)",
  food_div7 = "Mati√®res grasses (jours)"
)

# Cr√©er une table tibble
table_poids <- tibble(
  Variable = names(sca_poids),
  `Groupe alimentaire` = libelles[names(sca_poids)],
  `Poids attribu√©` = unname(sca_poids)
) %>%
  add_row(
    Variable = NA,
    `Groupe alimentaire` = "Total",
    `Poids attribu√©` = sum(sca_poids)
  )

# Flextable avec l√©gende
flextable(table_poids) %>%
  autofit() %>%
  set_caption("Poids attribu√©s aux groupes alimentaires pour le calcul du Food Consumption Score (FCS)") %>% 
 theme_zebra()


```

### Categorisation du SCA selon les seuil (21 et 35 / 28 et 42)

```{r}
base_principale <- base_principale %>%
  mutate(
    SCA_cat1 = case_when(
      SCA <= 21 ~ "Faible",
      SCA <= 35 ~ "Limite",
      SCA > 35 ~ "Acceptable"
    )
  )


```


```{r}
base_principale <- base_principale %>%
  mutate(
    SCA_cat2 = case_when(
      SCA <= 28 ~ "Faible",
      SCA <= 42 ~ "Limite",
      SCA > 42 ~ "Acceptable"
    )
  )


```

```{r}


# S√©lectionner les 10 premi√®res lignes avec les colonnes demand√©es
table_sca <- base_principale %>%
  select(id, SCA, SCA_cat1,SCA_cat2) %>%
  slice_head(n = 10)

# Cr√©er la flextable
flextable(table_sca) %>%
  autofit() %>%
  set_caption("Aper√ßu des 10 premi√®res observations du score de consommation alimentaire (SCA)") %>%
  theme_vanilla()

```

Le tableau ci-dessus, resume les diff√©rents score SCA mais pour quelques individus de la base.


### Faites une r√©presentation spatiale (r√©gion et d√©partement) du SCA et de ses diff√©rentes cat√©gorisations.

üéØ Objectif : Visualiser la moyenne du SCA ou la part des m√©nages par cat√©gorie dans chaque r√©gion ou d√©partement.

### Moyenne du SCA par r√©gion :


```{r results='hide',message=FALSE}
shp_adm1_sdn <- sf::st_read("../Data/Shapefile/ssd_admbnda_adm1_imwg_nbs_20230829.shp") ## Shapefile delimitant par r√©gion du soudan
```

```{r include=FALSE}
# Carte simple du soudan
tmap::tm_shape(shp_adm1_sdn) +
  tmap::tm_borders() +
  tmap::tm_fill("ADM1_EN", palette = "Set3", title = "R√©gions")
```



### V√©rification des noms des r√©gions

```{r}

# Nettoyage des noms dans base_principale
base_principale_carte <- base_principale %>%
  mutate(admin1 = admin1 %>%
           str_to_upper() %>%                          # Convertit tous les caract√®res en majuscules
           stri_trans_general("Latin-ASCII") %>%       # Supprime les accents (ex : √â ‚Üí E)
           str_replace_all("-", " ") %>%               # Remplace les tirets par des espaces
         #  str_replace_all("'", "") %>%                # Supprime les apostrophes
           str_replace_all("\\s+", " ") %>%            # Remplace plusieurs espaces par un seul
           str_trim())                                 # Supprime les espaces au d√©but et √† la fin

# Nettoyage des noms dans le shapefile
shp_adm1_sdn <- shp_adm1_sdn %>%
  mutate(ADM1_EN = ADM1_EN %>%
           str_to_upper() %>%                          # Convertit en majuscules
           stri_trans_general("Latin-ASCII") %>%       # Supprime les accents
           str_replace_all("-", " ") %>%               # Remplace les tirets par des espaces
         #  str_replace_all("'", "") %>%                # Supprime les apostrophes
           str_replace_all("\\s+", " ") %>%            # Remplace les multiples espaces par un seul
           str_trim())                                 # Supprime les espaces inutiles autour du texte


```

```{r}
# Afficher les r√©gions qui sont dans la base principale mais pas dans le shapefile
setdiff(unique(base_principale_carte$admin1), unique(shp_adm1_sdn$ADM1_EN))


```

```{r}
sca_region <- base_principale_carte %>%
  group_by(admin1) %>%
  summarise(SCA_moyen = mean(SCA, na.rm = TRUE)) %>% 
  
  mutate(
    SCA_moyen_cat2 = case_when(
      SCA_moyen <= 28 ~ "Faible",
      SCA_moyen <= 42 ~ "Limite",
      SCA_moyen > 42 ~ "Acceptable"
    )
  ) %>% 
  ungroup()

sca_region
```

```{r}

sca_region$admin1 <- as.character(sca_region$admin1)
shp_adm1_sdn <- shp_adm1_sdn %>% 
  left_join(sca_region, by = c("ADM1_EN" = "admin1"))


```

```{r}

ggplot(data = shp_adm1_sdn) +
  geom_sf(aes(fill = SCA_moyen), color = "white") +
  scale_fill_viridis_c(option = "plasma", name = "SCA moyen") +
  geom_sf_text(aes(label = ADM1_EN), size = 3, color = "black") +  # Noms des r√©gions
  labs(title = "Carte du Score de Consommation Alimentaire (SCA) par r√©gion") +
  theme_minimal()



```

```{r}

ggplot(data = shp_adm1_sdn) +
  geom_sf(aes(fill = SCA_moyen_cat2), color = "black") +   # Remplissage par cat√©gorie
  scale_fill_manual(
    values = c("Faible" = "red", "Limite" = "orange", "Acceptable" = "green"), 
    na.translate = FALSE,
    name = "Cat√©gorie SCA"
  ) +
   geom_sf_text(aes(label = ADM1_EN), size = 3, color = "black") +  # Noms des r√©gions
  labs(title = "Carte des cat√©gories du SCA par r√©gion") +
  theme_minimal()


```


Cette carte r√©v√®le que parmi les r√©gions couvertes par l‚Äôenqu√™te, aucune n‚Äôaffiche un score moyen ou √©lev√©. L‚Äôensemble des r√©gions pr√©sentent uniquement des scores faibles, traduisant une situation globalement pr√©occupante.

# 


```{r}


```
